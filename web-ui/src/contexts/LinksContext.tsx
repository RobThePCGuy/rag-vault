import { createContext, useCallback, useContext, useMemo, type ReactNode } from 'react'
import { recordFeedback } from '../api/client'
import { useLocalStorage } from '../hooks/useLocalStorage'

// ============================================
// Types
// ============================================

export interface ChunkKey {
  filePath: string
  chunkIndex: number
  /** Content-based fingerprint for resilient linking (optional for backwards compatibility) */
  fingerprint?: string
}

export interface PinnedLink {
  id: string
  createdAt: string
  sourceKey: ChunkKey
  sourceText: string
  sourceFingerprint: string
  targetKey: ChunkKey
  targetText: string
  targetFingerprint: string
  label?: string
  autoGenerated: boolean
  originalScore?: number
}

export interface TrailStep {
  chunkKey: ChunkKey
  visitedAt: string
  connectionReason?: string
}

/**
 * Trail node for Folgezettel branching structure
 * Supports tree-like navigation with branch labels (1a, 1b, etc.)
 */
export interface TrailNode {
  id: string
  chunkKey: ChunkKey
  visitedAt: string
  connectionReason?: string
  branchLabel?: string // e.g., "1a", "1b"
  children: TrailNode[]
}

export interface Trail {
  id: string
  name: string
  createdAt: string
  updatedAt: string
  /** Linear steps (legacy, for backwards compatibility) */
  steps: TrailStep[]
  /** Tree structure for Folgezettel branching (optional) */
  root?: TrailNode
}

export interface Bookmark {
  id: string
  chunkKey: ChunkKey
  note?: string
  createdAt: string
}

export interface LinksStore {
  version: 1
  vaultId: string
  pins: PinnedLink[]
  trails: Trail[]
  bookmarks: Bookmark[]
}

export interface PinOptions {
  label?: string
  autoGenerated?: boolean
  originalScore?: number
}

export interface LinksContextValue {
  // Pins
  pins: PinnedLink[]
  createPin: (
    source: ChunkKey,
    target: ChunkKey,
    sourceText: string,
    targetText: string,
    options?: PinOptions
  ) => PinnedLink
  deletePin: (pinId: string) => void
  updatePinLabel: (pinId: string, label: string) => void
  getPinsFromChunk: (key: ChunkKey) => PinnedLink[]
  getBacklinks: (key: ChunkKey) => PinnedLink[]
  isPinned: (source: ChunkKey, target: ChunkKey) => boolean

  // Trails
  trails: Trail[]
  currentTrail: Trail | null
  startNewTrail: () => void
  addToTrail: (key: ChunkKey, reason?: string) => void
  saveTrail: (name: string) => Trail
  loadTrail: (trailId: string) => Trail | null
  deleteTrail: (trailId: string) => void
  clearCurrentTrail: () => void

  // Bookmarks (Phase 7)
  bookmarks: Bookmark[]
  createBookmark: (chunkKey: ChunkKey, note?: string) => Bookmark
  deleteBookmark: (bookmarkId: string) => void
  updateBookmarkNote: (bookmarkId: string, note: string) => void
  getBookmarksForDocument: (filePath: string) => Bookmark[]
  isBookmarked: (chunkKey: ChunkKey) => boolean
  toggleBookmark: (chunkKey: ChunkKey) => boolean // returns new state

  // Export/Import
  exportLinks: () => string
  importLinks: (json: string) => { imported: number; errors: string[] }
}

// ============================================
// Utilities
// ============================================

function generateId(): string {
  return crypto.randomUUID()
}

async function hashText(text: string): Promise<string> {
  const encoder = new TextEncoder()
  const data = encoder.encode(text)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')
}

function isSameChunkKey(a: ChunkKey, b: ChunkKey): boolean {
  // Prefer fingerprint comparison if both have fingerprints (Resilient Linking v0)
  if (a.fingerprint && b.fingerprint) {
    return a.fingerprint === b.fingerprint
  }
  // Fallback to path + index comparison
  return a.filePath === b.filePath && a.chunkIndex === b.chunkIndex
}

const DEFAULT_STORE: LinksStore = {
  version: 1,
  vaultId: '',
  pins: [],
  trails: [],
  bookmarks: [],
}

// ============================================
// Context
// ============================================

const LinksContext = createContext<LinksContextValue | null>(null)

interface LinksProviderProps {
  children: ReactNode
  vaultId?: string
}

export function LinksProvider({ children, vaultId = 'default' }: LinksProviderProps) {
  const storageKey = `rag-vault-links-v1-${vaultId}`
  const [store, setStore] = useLocalStorage<LinksStore>(storageKey, {
    ...DEFAULT_STORE,
    vaultId,
  })

  // ============================================
  // Pin Operations
  // ============================================

  const createPin = useCallback(
    (
      source: ChunkKey,
      target: ChunkKey,
      sourceText: string,
      targetText: string,
      options?: PinOptions
    ): PinnedLink => {
      const pin: PinnedLink = {
        id: generateId(),
        createdAt: new Date().toISOString(),
        sourceKey: source,
        sourceText: sourceText.slice(0, 200),
        sourceFingerprint: '', // Will be set async
        targetKey: target,
        targetText: targetText.slice(0, 200),
        targetFingerprint: '', // Will be set async
        label: options?.label,
        autoGenerated: options?.autoGenerated ?? false,
        originalScore: options?.originalScore,
      }

      // Update fingerprints asynchronously
      Promise.all([hashText(sourceText), hashText(targetText)])
        .then(([sourceFingerprint, targetFingerprint]) => {
          setStore((prev) => ({
            ...prev,
            pins: prev.pins.map((p) =>
              p.id === pin.id ? { ...p, sourceFingerprint, targetFingerprint } : p
            ),
          }))

          // Record feedback event for flywheel (fire and forget)
          recordFeedback(
            'pin',
            { ...source, fingerprint: sourceFingerprint },
            { ...target, fingerprint: targetFingerprint }
          ).catch(() => {
            // Silently ignore feedback errors - non-critical
          })
        })
        .catch((error) => {
          console.warn('Failed to hash text for pin fingerprints:', error)
        })

      setStore((prev) => ({
        ...prev,
        pins: [...prev.pins, pin],
      }))

      return pin
    },
    [setStore]
  )

  const deletePin = useCallback(
    (pinId: string) => {
      // Find the pin before deleting to send feedback
      const pin = store.pins.find((p) => p.id === pinId)

      setStore((prev) => ({
        ...prev,
        pins: prev.pins.filter((p) => p.id !== pinId),
      }))

      // Record unpin feedback event (fire and forget)
      if (pin) {
        recordFeedback(
          'unpin',
          { ...pin.sourceKey, fingerprint: pin.sourceFingerprint },
          { ...pin.targetKey, fingerprint: pin.targetFingerprint }
        ).catch(() => {
          // Silently ignore feedback errors - non-critical
        })
      }
    },
    [setStore, store.pins]
  )

  const updatePinLabel = useCallback(
    (pinId: string, label: string) => {
      setStore((prev) => ({
        ...prev,
        pins: prev.pins.map((p) => (p.id === pinId ? { ...p, label } : p)),
      }))
    },
    [setStore]
  )

  const getPinsFromChunk = useCallback(
    (key: ChunkKey): PinnedLink[] => {
      return store.pins.filter((p) => isSameChunkKey(p.sourceKey, key))
    },
    [store.pins]
  )

  const getBacklinks = useCallback(
    (key: ChunkKey): PinnedLink[] => {
      return store.pins.filter((p) => isSameChunkKey(p.targetKey, key))
    },
    [store.pins]
  )

  const isPinned = useCallback(
    (source: ChunkKey, target: ChunkKey): boolean => {
      return store.pins.some(
        (p) => isSameChunkKey(p.sourceKey, source) && isSameChunkKey(p.targetKey, target)
      )
    },
    [store.pins]
  )

  // ============================================
  // Trail Operations
  // ============================================

  const [currentTrail, setCurrentTrail] = useLocalStorage<Trail | null>(
    `rag-vault-current-trail-${vaultId}`,
    null
  )

  const startNewTrail = useCallback(() => {
    const trail: Trail = {
      id: generateId(),
      name: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      steps: [],
    }
    setCurrentTrail(trail)
  }, [setCurrentTrail])

  const addToTrail = useCallback(
    (key: ChunkKey, reason?: string) => {
      setCurrentTrail((prev) => {
        if (!prev) {
          // Start a new trail automatically
          const trail: Trail = {
            id: generateId(),
            name: '',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            steps: [
              {
                chunkKey: key,
                visitedAt: new Date().toISOString(),
                connectionReason: reason,
              },
            ],
          }
          return trail
        }

        // Don't add duplicate consecutive steps
        const lastStep = prev.steps[prev.steps.length - 1]
        if (lastStep && isSameChunkKey(lastStep.chunkKey, key)) {
          return prev
        }

        return {
          ...prev,
          updatedAt: new Date().toISOString(),
          steps: [
            ...prev.steps,
            {
              chunkKey: key,
              visitedAt: new Date().toISOString(),
              connectionReason: reason,
            },
          ],
        }
      })
    },
    [setCurrentTrail]
  )

  const saveTrail = useCallback(
    (name: string): Trail => {
      if (!currentTrail) {
        throw new Error('No current trail to save')
      }

      const savedTrail: Trail = {
        ...currentTrail,
        name,
        updatedAt: new Date().toISOString(),
      }

      setStore((prev) => ({
        ...prev,
        trails: [...prev.trails, savedTrail],
      }))

      setCurrentTrail(null)

      return savedTrail
    },
    [currentTrail, setStore, setCurrentTrail]
  )

  const loadTrail = useCallback(
    (trailId: string): Trail | null => {
      const trail = store.trails.find((t) => t.id === trailId)
      if (trail) {
        setCurrentTrail({ ...trail })
      }
      return trail || null
    },
    [store.trails, setCurrentTrail]
  )

  const deleteTrail = useCallback(
    (trailId: string) => {
      setStore((prev) => ({
        ...prev,
        trails: prev.trails.filter((t) => t.id !== trailId),
      }))
    },
    [setStore]
  )

  const clearCurrentTrail = useCallback(() => {
    setCurrentTrail(null)
  }, [setCurrentTrail])

  // ============================================
  // Bookmark Operations (Phase 7)
  // ============================================

  const createBookmark = useCallback(
    (chunkKey: ChunkKey, note?: string): Bookmark => {
      const bookmark: Bookmark = {
        id: generateId(),
        chunkKey,
        note,
        createdAt: new Date().toISOString(),
      }

      setStore((prev) => ({
        ...prev,
        bookmarks: [...(prev.bookmarks || []), bookmark],
      }))

      return bookmark
    },
    [setStore]
  )

  const deleteBookmark = useCallback(
    (bookmarkId: string) => {
      setStore((prev) => ({
        ...prev,
        bookmarks: (prev.bookmarks || []).filter((b) => b.id !== bookmarkId),
      }))
    },
    [setStore]
  )

  const updateBookmarkNote = useCallback(
    (bookmarkId: string, note: string) => {
      setStore((prev) => ({
        ...prev,
        bookmarks: (prev.bookmarks || []).map((b) => (b.id === bookmarkId ? { ...b, note } : b)),
      }))
    },
    [setStore]
  )

  const getBookmarksForDocument = useCallback(
    (filePath: string): Bookmark[] => {
      return (store.bookmarks || [])
        .filter((b) => b.chunkKey.filePath === filePath)
        .sort((a, b) => a.chunkKey.chunkIndex - b.chunkKey.chunkIndex)
    },
    [store.bookmarks]
  )

  const isBookmarked = useCallback(
    (chunkKey: ChunkKey): boolean => {
      return (store.bookmarks || []).some((b) => isSameChunkKey(b.chunkKey, chunkKey))
    },
    [store.bookmarks]
  )

  const toggleBookmark = useCallback(
    (chunkKey: ChunkKey): boolean => {
      const existing = (store.bookmarks || []).find((b) => isSameChunkKey(b.chunkKey, chunkKey))

      if (existing) {
        deleteBookmark(existing.id)
        return false
      } else {
        createBookmark(chunkKey)
        return true
      }
    },
    [store.bookmarks, createBookmark, deleteBookmark]
  )

  // ============================================
  // Export/Import
  // ============================================

  const exportLinks = useCallback((): string => {
    return JSON.stringify(store, null, 2)
  }, [store])

  const importLinks = useCallback(
    (json: string): { imported: number; errors: string[] } => {
      const errors: string[] = []
      let imported = 0

      try {
        const data = JSON.parse(json) as LinksStore

        if (data.version !== 1) {
          errors.push(`Unsupported version: ${data.version}`)
          return { imported, errors }
        }

        // Import pins
        if (Array.isArray(data.pins)) {
          for (const pin of data.pins) {
            if (
              pin.id &&
              pin.sourceKey &&
              pin.targetKey &&
              !store.pins.some((p) => p.id === pin.id)
            ) {
              setStore((prev) => ({
                ...prev,
                pins: [...prev.pins, pin],
              }))
              imported++
            }
          }
        }

        // Import trails
        if (Array.isArray(data.trails)) {
          for (const trail of data.trails) {
            if (
              trail.id &&
              trail.name &&
              Array.isArray(trail.steps) &&
              !store.trails.some((t) => t.id === trail.id)
            ) {
              setStore((prev) => ({
                ...prev,
                trails: [...prev.trails, trail],
              }))
              imported++
            }
          }
        }

        // Import bookmarks
        if (Array.isArray(data.bookmarks)) {
          for (const bookmark of data.bookmarks) {
            if (
              bookmark.id &&
              bookmark.chunkKey &&
              !(store.bookmarks || []).some((b) => b.id === bookmark.id)
            ) {
              setStore((prev) => ({
                ...prev,
                bookmarks: [...(prev.bookmarks || []), bookmark],
              }))
              imported++
            }
          }
        }
      } catch (e) {
        errors.push(`Invalid JSON: ${(e as Error).message}`)
      }

      return { imported, errors }
    },
    [store, setStore]
  )

  // ============================================
  // Context Value
  // ============================================

  const value = useMemo<LinksContextValue>(
    () => ({
      pins: store.pins,
      createPin,
      deletePin,
      updatePinLabel,
      getPinsFromChunk,
      getBacklinks,
      isPinned,
      trails: store.trails,
      currentTrail,
      startNewTrail,
      addToTrail,
      saveTrail,
      loadTrail,
      deleteTrail,
      clearCurrentTrail,
      // Bookmarks
      bookmarks: store.bookmarks || [],
      createBookmark,
      deleteBookmark,
      updateBookmarkNote,
      getBookmarksForDocument,
      isBookmarked,
      toggleBookmark,
      exportLinks,
      importLinks,
    }),
    [
      store.pins,
      store.trails,
      store.bookmarks,
      createPin,
      deletePin,
      updatePinLabel,
      getPinsFromChunk,
      getBacklinks,
      isPinned,
      currentTrail,
      startNewTrail,
      addToTrail,
      saveTrail,
      loadTrail,
      deleteTrail,
      clearCurrentTrail,
      createBookmark,
      deleteBookmark,
      updateBookmarkNote,
      getBookmarksForDocument,
      isBookmarked,
      toggleBookmark,
      exportLinks,
      importLinks,
    ]
  )

  return <LinksContext.Provider value={value}>{children}</LinksContext.Provider>
}

export function useLinks(): LinksContextValue {
  const context = useContext(LinksContext)
  if (!context) {
    throw new Error('useLinks must be used within a LinksProvider')
  }
  return context
}
