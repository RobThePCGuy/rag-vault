import { useMemo, useCallback } from 'react'
import type { RelatedChunk } from '../api/client'
import { useLinks, type ChunkKey } from '../contexts/LinksContext'
import { useLocalStorage } from './useLocalStorage'

// ============================================
// Types
// ============================================

export interface InferredBacklink {
  id: string
  sourceKey: ChunkKey
  targetKey: ChunkKey
  score: number
  sourcePreview: string
  targetPreview: string
  reason: string
}

interface UseInferredBacklinksOptions {
  currentFilePath: string
  currentChunkIndex: number | null
  relatedChunks: RelatedChunk[]
  /** Similarity threshold (lower is more similar) */
  threshold?: number
  /** Maximum number of suggestions to show */
  maxSuggestions?: number
}

interface DismissedSuggestions {
  version: 1
  dismissedIds: string[]
}

interface UseInferredBacklinksResult {
  /** Inferred backlinks that haven't been pinned or dismissed */
  suggestions: InferredBacklink[]
  /** Pin a suggestion (creates a real backlink) */
  pinSuggestion: (suggestion: InferredBacklink) => void
  /** Dismiss a suggestion (hides it) */
  dismissSuggestion: (suggestion: InferredBacklink) => void
  /** Check if we have any suggestions */
  hasSuggestions: boolean
  /** Total number of potential links (before filtering) */
  totalPotential: number
}

// ============================================
// Hook
// ============================================

/**
 * Hook for suggesting backlinks based on semantic similarity
 */
export function useInferredBacklinks({
  currentFilePath,
  currentChunkIndex,
  relatedChunks,
  threshold = 0.5,
  maxSuggestions = 5,
}: UseInferredBacklinksOptions): UseInferredBacklinksResult {
  const { pins, createPin } = useLinks()

  // Persisted dismissed suggestions
  const [dismissed, setDismissed] = useLocalStorage<DismissedSuggestions>(
    'rag-vault-dismissed-suggestions',
    { version: 1, dismissedIds: [] }
  )

  // Check if a link already exists between two chunks
  const linkExists = useCallback(
    (sourceKey: ChunkKey, targetKey: ChunkKey): boolean => {
      return pins.some(
        (pin) =>
          (isSameKey(pin.sourceKey, sourceKey) && isSameKey(pin.targetKey, targetKey)) ||
          (isSameKey(pin.sourceKey, targetKey) && isSameKey(pin.targetKey, sourceKey))
      )
    },
    [pins]
  )

  // Generate suggestions from related chunks
  const allSuggestions = useMemo(() => {
    if (currentChunkIndex === null) return []

    const currentKey: ChunkKey = {
      filePath: currentFilePath,
      chunkIndex: currentChunkIndex,
    }

    return relatedChunks
      .filter((chunk) => {
        // Must be below threshold (more similar)
        if (chunk.score >= threshold) return false

        // Must be from different document (cross-document discovery)
        if (chunk.filePath === currentFilePath) return false

        const targetKey: ChunkKey = {
          filePath: chunk.filePath,
          chunkIndex: chunk.chunkIndex,
        }

        // Must not already be linked
        if (linkExists(currentKey, targetKey)) return false

        return true
      })
      .map((chunk): InferredBacklink => {
        const id = `${currentFilePath}:${currentChunkIndex}:${chunk.filePath}:${chunk.chunkIndex}`

        return {
          id,
          sourceKey: currentKey,
          targetKey: {
            filePath: chunk.filePath,
            chunkIndex: chunk.chunkIndex,
          },
          score: chunk.score,
          sourcePreview: '', // Would need current chunk text
          targetPreview: chunk.text.slice(0, 150),
          reason: inferReason(chunk.score),
        }
      })
      .sort((a, b) => a.score - b.score) // Lower score = more similar = first
  }, [currentFilePath, currentChunkIndex, relatedChunks, threshold, linkExists])

  // Filter out dismissed suggestions
  const suggestions = useMemo(() => {
    const dismissedSet = new Set(dismissed.dismissedIds)
    return allSuggestions.filter((s) => !dismissedSet.has(s.id)).slice(0, maxSuggestions)
  }, [allSuggestions, dismissed.dismissedIds, maxSuggestions])

  // Pin a suggestion
  const pinSuggestion = useCallback(
    (suggestion: InferredBacklink) => {
      createPin(
        suggestion.sourceKey,
        suggestion.targetKey,
        suggestion.sourcePreview,
        suggestion.targetPreview,
        {
          label: `Inferred (${Math.round((1 - suggestion.score) * 100)}% similar)`,
          autoGenerated: false,
          originalScore: suggestion.score,
        }
      )
    },
    [createPin]
  )

  // Dismiss a suggestion
  const dismissSuggestion = useCallback(
    (suggestion: InferredBacklink) => {
      setDismissed((prev) => ({
        ...prev,
        dismissedIds: [...prev.dismissedIds, suggestion.id],
      }))
    },
    [setDismissed]
  )

  return {
    suggestions,
    pinSuggestion,
    dismissSuggestion,
    hasSuggestions: suggestions.length > 0,
    totalPotential: allSuggestions.length,
  }
}

// ============================================
// Helpers
// ============================================

function isSameKey(a: ChunkKey, b: ChunkKey): boolean {
  return a.filePath === b.filePath && a.chunkIndex === b.chunkIndex
}

function inferReason(score: number): string {
  const similarity = Math.round((1 - score) * 100)
  if (similarity >= 80) return 'Very high similarity'
  if (similarity >= 60) return 'High similarity'
  if (similarity >= 40) return 'Moderate similarity'
  return 'Similar content'
}
